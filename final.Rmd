---
title: "應用線性統計模型_期末報告"
subtitle: "2018 年公投第 14 案回歸模型探討"
author: 
- "心理三 B05207063 楊昊紘"
- "心理五 B03605059 林子堯"
- "心理三 B04902070 楊聖斌"
- "心理三 B05207045 張倚郡"
date: "`r Sys.Date()`"
output:
  xaringan::moon_reader:
    css: [default, my-theme.css]
    lib_dir: libs
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
      navigation:
        scroll: false # disable slide transitions by scrolling
---

```{r setup, include=FALSE}
options(htmltools.dir.version = FALSE)
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
```

# QR-code 

.large[
[https://bit.ly/2ZcWYvw](https://bit.ly/2ZcWYvw)
]
```{r, fig.align="center"}
knitr::include_graphics("figure/QR_code.png")
```

---

# 前言

2018年11月24日中華民國全國性公民投票結果  
![](figure/referendum result.jpg)

---

# 性平公投 vs. 愛家公投 

.pull-left[
```{r, out.width="100%"}
knitr::include_graphics("figure/性平公投.jpg")
```
]

--

.pull-right[
```{r, out.width="100%"}
knitr::include_graphics("figure/愛家公投.png")
```
]

---

# 探討對象

.scroll-output[
```{r, out.width="60%", fig.align="center"}
knitr::include_graphics("figure/公投第14案.png")
```
]

---

# Outline

.Large[
1. .grey[前言與研究目的]

2. 文獻回顧

3. 資料來源與前處理

4. 迴歸模型

5. 總結
]

---
class: inverse, center, middle

# 文獻回顧

---

# 同性戀態度

---
class: inverse, center, middle

# 資料來源與前處理

---

# 資料來源
- 公投：
    + [政府資料開放平臺_第14案全國性公民投票計票結果](https://data.gov.tw/dataset/95883)
    
- 人口年齡組成：
    + [內政資料開放平臺_村里戶數、單一年齡人口（新增區域代碼）](https://bit.ly/30DWL5J)
    
- 結婚與教育：
    + [內政資料開放平臺_15歲以上現住人口按性別、年齡、婚姻狀況及教育程度分](https://bit.ly/2QdqGgk)
    
- 薪水中位數：
    + [財政部財政資訊中心_105年度綜合所得稅申報核定統計專冊](https://bit.ly/2M3IiwY)


資料數量：全台鄉、鎮、市、區共 368 個  
.red[反應變項]：公投第14案同意率  
.blue[預測變項]：投票率、地區(是否為六都)、性別比、年齡、婚姻、教育程度、薪水收入

---

# 公投第 14 案

```{r}
source("my_custom_function.R")
```

.pull-left_25[
```{r, comment=NA}
library(dplyr)
library(tidyr)

Data <- readRDS("Data.rds")

print_summary(Data$agree_rate)
```
]

.pull-right_70[
```{r, fig.width=10, fig.height=10, out.width="90%", fig.align="center"}
library(ggplot2)
ggplot(Data, aes(x = agree_rate, fill = location)) +
  geom_histogram() +
  theme_bw() +
  theme(legend.position = "top") 
```
]

---

# 投票率

.pull-left_25[
```{r, comment=NA}
print_summary(Data$vote_rate)
```
]

.pull-right_70[
```{r, fig.width=10, fig.height=10, out.width="90%", fig.align="center"}
scatter_and_histogram_plot(Data, .x = "vote_rate", .y = "agree_rate", .group = "location")
```
]

---

# 性別比

.pull-left_25[
```{r, comment=NA}
print_summary(Data$gender_ratio)
```
]

.pull-right_70[
```{r, fig.width=10, fig.height=10, out.width="90%", fig.align="center"}
scatter_and_histogram_plot(Data, .x = "gender_ratio", .y = "agree_rate", .group = "location")
```
]
---

# 年齡組成

.pull-left_30[

- 老人多且較無法接受?  
- 都是老人去投票？  

.scroll-box-20[
年齡中位數比例
```{r, comment=NA}
print_summary(Data$age_med)
```

老年人(65~)比例
```{r, comment=NA}
print_summary(Data$old_ratio)
```

中年人(31~64)比例
```{r, comment=NA}
print_summary(Data$old_ratio)
```

年輕人(18~30)比例
```{r, comment=NA}
print_summary(Data$young_ratio)
```
]]

.pull-right_70[
```{r, fig.width=10, fig.height=10, out.width="90%", fig.align="center"}
g <- Data %>% 
  select(agree_rate, old_ratio, middle_ratio, young_ratio, age_med, location) %>% 
  gather(key = ageGroup, value = ratio, old_ratio, middle_ratio, young_ratio, age_med) %>% 
  ggplot(aes(x = ratio, y = agree_rate)) +
  geom_point(aes(color = location)) +
  geom_smooth(method = lm) + 
  facet_wrap(~ageGroup, scales = "free") +
  theme_bw() +
  theme(legend.position = "top") 
g
```
]

---

# 結婚狀況

.pull-left_30[
$曾今結婚率=\frac{喪偶＋有偶+離婚}{Total}$


```{r, comment=NA}
print_summary(Data$married_ratio)
```
]

.pull-right_70[
```{r, fig.width=10, fig.height=10, out.width="90%", fig.align="center"}
scatter_and_histogram_plot(Data, .x = "married_ratio", .y = "agree_rate", .group = "location")
```
]

---

# 教育程度

.pull-left_30[
$大專畢業的比例=\frac{大學+大專+碩士+博士}{Total}$  


```{r, comment=NA}
print_summary(Data$college_ratio)
```
]

.pull-right_70[
```{r, fig.width=10, fig.height=10, out.width="90%", fig.align="center"}
scatter_and_histogram_plot(Data, .x = "college_ratio", .y = "agree_rate", .group = "location")
```
]

---

# 薪水中位數

.pull-left_30[
```{r, comment=NA}
print_summary(Data$salary_med)
```
]

.pull-right_70[
```{r, fig.width=10, fig.height=10, out.width="90%", fig.align="center"}
scatter_and_histogram_plot(Data, .x = "salary_med", .y = "agree_rate", .group = "location")
```
]

---

# 資料地圖 [(連結)](https://xup6y3ul6.github.io/ALSN_final_report/referendum14_map.html#1)

```{r, fig.height=6, out.width="60%", fig.align="center"}
knitr::include_graphics("figure/map.png")
```

---

# 變數介紹

.Large[
Y : agree      第14案公投同意率  
X1: vote       投票率  
X2: bigCity    是否為六都 $=\left\{\begin{matrix}0,\,非六都\\1,\,是六都\end{matrix}\right.$  
X3: gender     性別比  
X4: young      年輕人(18~30)比例  
X5: middel     中年人(31~64)比例  
X6: age        年齡中位數  
X7: married    結過婚比例  
X8: education  教育程度(大專生畢業比例)  
X9: salary     薪水中位數  
]
---

# scatter-correlation plot

```{r, fig.align="center", fig.height=7.5, fig.width=10}
data <- Data %>% 
  select(agree_rate,     # Y
         vote_rate,      # X1
         is_municipality,# X2 
         gender_ratio,   # X3
         young_ratio,    # X4
         middle_ratio,   # X5
         age_med,        # X6
         married_ratio,  # X7
         college_ratio,  # X8
         salary_med)     # X9
.names <- names(data)
names(data) <- c("Y", paste0("X", 1:(length(.names)-1)))
names(data) <- c("agree",
                 "vote",
                 "bigCity",
                 "gender",
                 "young",
                 "middle",
                 "age",
                 "married",
                 "education",
                 "salary")
#data$bigCity <- factor(data$bigCity, levels = c("0", "1"))
library(GGally)

ggpairs(data, 
        upper = list(continuous = my_custom_cor_color),
        lower = list(continuous = my_custom_smooth)) 
```

---
class: inverse, center, middle

# 回歸模型

---

# 建模流程

需要流程圖
！[]()

---

# first ordinal regression

agree(Y) = vote(X1) + bigCity(X2) + gender(X3) + young(X4) + middle(X5) + age(X6) + married(X7) + education(X8) + salary(X9)
         
--

```{r, comment=NA, highlight.output=c(2,3,4,6,7,8,9,10)}
library(car)
model_1st <- lm(agree ~ ., data)
. <- summary(model_1st)
.df <- .$coefficients %>% round(digits = 3) %>% as.data.frame()
.df$signif <- symnum(
  .df$"Pr(>|t|)",
  cutpoints = c(0, 0.001, 0.01, 0.05, 0.1, 1),
  symbols = c("***", "**", "*", ".", " ")
)
.df
```

```{r, comment=NA}
write.table(paste("Multiple R-squared:", round(.$r.squared, 3), ", ", "Adjusted R-squared:", round(.$adj.r.squared, 3)), 
            quote = FALSE, row.names = FALSE, col.names = FALSE)
```

---

# residul plot

```{r, fig.align="center", fig.height=7, fig.width=10}
model_1st_data <- cbind(data,
                        res = residuals(model_1st),
                        fit = predict(model_1st))
Xnames <- names(data)[-1]
g <- lapply(Xnames, function(X){
  ggplot(model_1st_data, aes_string(x = X, y = "res")) +
  geom_point() +
  theme_bw()
})

gridExtra::grid.arrange(grobs = g, nrow = 3)
```

可發現總有一筆 data .lightPink[連江縣東引鄉] 總是不一樣  
但變異數似乎沒有不同質

---

# Q-Q plot

```{r}
ggplot(model_1st_data, aes(sample = res)) +
  geom_qq() +
  geom_qq_line(color = "red", line.p = c(0.25, 0.75), linetype = "dashed") + 
  theme_bw()
```

```{r}
model_1st_qq <- qqnorm(model_1st_data$res, plot.it = FALSE)
cor(model_1st_qq$x, model_1st_qq$y)
```

---

# add-variable plot

```{r}
# par(mfcol = c(3,3))
# 
# testdata = data
# . <- testdata$bigCity %>% as.character() %>% as.numeric()
# testdata$bigCity <- .
# for(i in 1:(dim(testdata)[2]-2)){
#   for(j in (i+1):(dim(testdata)[2]-1)){
#       .testdata=testdata
#       modelY=lm(agree~.,.testdata)
#       .X=select(testdata,-agree)
#         
#       modelX=lm(.X[,names(.X)[i]]*.X[,names(.X)[j]]~., .X)
#        
#       . <- data.frame(xres = modelX$residuals, yres = modelY$residuals) 
#    # #   ggplot(., aes(xres, yres)) +
#    #      geom_point() +
#    #      geom_smooth(method="lm") +
#    #      theme_bw()
#       plot(modelX$residuals, modelY$residuals,xlab = c(names(testdata)[i+1], names(testdata)[j+1]), ylab = "e(Y|other variable)",main = "add variable plot")
#       
#       abline(lm(modelY$residuals~modelX$residuals,.))
#       
#   }
# }

```
 

---

# find better models

```{r, fig.align="center"}
library(leaps)
library(MPV)
library(DT)
best <- function(model, nbest = 1, nvmax = 8, ...) {
  subsets <- regsubsets(formula(model), model.frame(model), nbest = nbest, nvmax = nvmax, ...)
  subsets <- with(summary(subsets),
                  cbind(p = as.numeric(rownames(which)) + 1, 
                        which, rss, rsq, adjr2, cp, bic))
  subsets <- as.data.frame(subsets)
  subsets$aic <- subsets$bic - log(nrow(model.frame(model)))*subsets$p + 2*subsets$p
  rownames(subsets) <- NULL
  
  # press
  .combination <- lapply(1:nrow(subsets), function(x){
    colnames(subsets)[which(subsets[x, 3:(ncol(subsets)-6)] == 1)+2]
  })

  .Y <- formula(model_1st) %>% as.character() %>% strsplit(" ~ ")
  Y <- .Y[[2]]
  combination <- lapply(.combination, function(x){
    X <- x %>% gsub(pattern = "[0-9]", replacement = "") # remove factor integer
    paste(Y, "~", paste(X, collapse = "+"))
  }) 
  lm_combination <- lapply(combination, function(x){lm(as.formula(x), data = model.frame(model))}) 
  press <- sapply(lm_combination, function(x){PRESS(x)})
  
  subsets$PRESS <- press
  
  return(subsets)
}  

.data <- best(lm(agree ~., data), nbest = 10, nvmax = 10) %>% 
  gather(key = index, value = value, rsq:PRESS)

criterion <- data.frame(
  index = c("rsq", "adjr2", "cp", "aic", "bic", "PRESS"),
  critera.fun = c("max", "max", "min", "min", "min", "min")
)

g <- list()

for(i in 1:nrow(criterion)){
  .index <- criterion[i, "index"]
  .critera.fun <- criterion[i, "critera.fun"] %>% as.character()
  
  g[[i]] <- .data %>% 
    filter(index == .index) %>% 
    ggplot(aes(x = p, y = value)) +
    geom_point(size = 0.6) +
    scale_x_continuous(breaks = unique(.data$p)) +
    stat_summary(fun.y = .critera.fun, colour = "orange", geom = "line") +
    labs(title = .index, y = NULL) +
    theme_bw()
}

grid.arrange(grobs = g, nrow = 2)
```

---

# find better model

.small[
```{r, fig.align="center"}

subsetsTable = round(best(lm(agree ~.,data), nbest = 2,nvmax=29), 4)
datatable(subsetsTable, 
          fillContainer = FALSE,
          extensions = 'FixedColumns',
          options = list(scrollX = TRUE,
                         fixedColumns = TRUE)
)
```
]

---

# 候選模型

- M1:

- M2:

- M3:

---

# BP test

---

# check outlier

.small[
```{r}
outlierDF <- data.frame(
  "e_i" = round(resid(model_1st), 3),
  "h_ii" = round(hatvalues(model_1st), 3),
  "t_i" = round(rstudent(model_1st), 3))

alpha <- 0.1
n <- nrow(model.frame(model_1st))
p <- length(coefficients(model_1st))

critical_by_Y <- qt((1-alpha/(2*n)), n-p-1) 
#outlierDF$outlier_by_Y <- outlierDF$t_i > critical_by_Y

critical_by_X <- 0.5
#critical_by_X <- 2*p/n
#outlierDF$outlier_by_X <- outlierDF$h_ii > critical_by_X

datatable(outlierDF,
          fillContainer = FALSE,
          extensions = 'FixedColumns',
          options = list(scrollX = TRUE,
                           fixedColumns = TRUE)) %>% 
  formatStyle(0:ncol(outlierDF), fontSize = "10pt") %>% 
  formatStyle("h_ii",
              color = styleInterval(c(critical_by_X), c('black', 'red'))) %>% 
  formatStyle("t_i",
              color = styleInterval(c(critical_by_Y), c('black', 'red'))) 
```
]

Bonferroni critical value = .red[3.68] ( $\alpha = 0.1$ )  
Leverage critical value = .large[0.5] (?? 2p/n = 0.054)

---

# check influence

.small[
```{r}
model <-model_1st
influentialDF <- data.frame(
  "DFFITS"   = dffits(model) %>% round(digits = 3),
  "Cooks_D"  = cooks.distance(model) %>% round(digits = 3),
  "DFBETA"   = dfbeta(model) %>% round(digits = 3)
)

sketch <-  htmltools::withTags(table(
  class = 'display',
  thead(
    tr(
      th(rowspan = 2, ""),
      th(rowspan = 2, 'DFFITS'),
      th(rowspan = 2, 'Cooks_D'),
      th(colspan = ncol(dfbeta(model)), 'DFBETA')
    ),
    tr(
      lapply(paste0("b_", 0:(ncol(dfbeta(model))-1)), th)
    )
  )
))

DFFITS_critical <- 2*sqrt(p/n)
CD_50 <- pf(0.5, p, n-p)
CD_20 <- pf(0.2, p, n-p)
DFBETAS_critical <- 2/sqrt(n)

datatable(influentialDF,
          fillContainer = FALSE,
          container = sketch,
          extensions = 'FixedColumns',
          options = list(scrollX = TRUE,
                         fixedColumns = FALSE,
                         pageLength = 10,
                         autoWidth = TRUE,
                         columnDefs = list(list(width = '65px', targets = c(0))))) %>% 
  formatStyle(0:ncol(influentialDF), fontSize = "10pt") %>% 
  formatStyle("DFFITS",
              color = styleInterval(c(-DFFITS_critical, DFFITS_critical), c('red', 'black', 'red'))) %>% 
  formatStyle("Cooks_D",
              color = styleInterval(c(CD_20, CD_50), c("black", "blue", "red"))) %>% 
  formatStyle(3:nrow(influentialDF),
              color = styleInterval(c(DFBETAS_critical), c("black", "red")))
```
]

DFFITS critical value = .red[0.33 ( $2\sqrt{p/n}$ )]  
Cooks' distance critical value: .red[large >50th], .blue[middle 20~50th]  
DFBETA critical value = .red[0.104 ( $2/\sqrt{n}$ )]

---

# Cook's distance plot

```{r,fig.align="center", fig.height=7.5, fig.width=10}
.data <- data.frame("res" = residuals(model_1st), 
                    "fit" = predict(model_1st),
                    "Cooks_D" = influentialDF$Cooks_D,
                    "index" = 1:nrow(data)
)
g_proportional <- ggplot(.data, aes(x = res, y = fit)) +
  geom_point(aes(size = Cooks_D)) +
  theme_bw() +
  theme(legend.justification=c(0,1), 
        legend.position=c(0.75, 0.99), 
        legend.background = element_rect(fill="transparent"))
g_index <- ggplot(.data, aes(x = index, y = Cooks_D)) +
  geom_line(color = "grey") +
  geom_point() +
  theme_bw() 
gridExtra::grid.arrange(g_proportional, g_index, nrow = 1)
```


---

# VIF

```{r, comment=NA}
#model_scale <- lm(scale(Y) ~ scale(.), data)
VIF <- data.frame(
  #"beta"       = as.vector(coef(model_1st)[-1]),
  #"beta_scale" = as.vector(coef(model_scale)[-1]),
  "VIF"        = car::vif(lm(model_1st))
)
VIF %>% round(digits = 3)
```

應該不需要對變異數不同質討論

---

# IRLS robust regression

```{r}
IRLS <- function(model, i = 1, method = c("Huber", "Bisquare"), is_first = TRUE) {
  e   <- resid(model)
  MAD <- median(abs(e - median(e))) / 0.6745  # (11.46)
  u   <- e / MAD  # (11.47)
  w   <- apply(data.frame(u), 1, function(x) {
    if (is_first | method == "Huber") {
      if (abs(x) <= 1.345) 1 else 1.345/abs(x)  # (11.44) Huber weight
    } else {
      if (abs(x) <= 1.345) (1-(x/4.685)^2)^2 else 0  # (11.45) Bisqure weight
    }
    
    
  })
    
  model <- update(model, weights = w)
  if (i > 1) return(IRLS(model, i-1, method = method, is_first = FALSE)) else return(model)  # Recursive return definition
}

tab <- cbind(
  "e0" = resid(model_1st),
  "u0" = resid(model_1st) / (median(abs(resid(model_1st) - median(resid(model_1st)))) / 0.6745),
  "w1" = IRLS(model_1st, 1)$weights,
  "e1" = resid( IRLS(model_1st, 1) ),
  "w2" = IRLS(model_1st, 2)$weights,
  "e2" = resid( IRLS(model_1st, 2) ),
  "w7" = IRLS(model_1st, 7)$weights,
  "e7" = resid( IRLS(model_1st, 7) ))

# round(tab, 4)

ggplot(data.frame(id = 1:nrow(tab), weight = tab[,7]), aes(x = id, y = weight)) +
  geom_point() +
  geom_path(size = 0.3, color = "grey") +
  theme_bw()
```

---

# Check influence again

.small[
```{r}
model <-lm(agree ~ ., data, weights = IRLS(model_1st, 7)$weights)
influentialDF <- data.frame(
  "DFFITS"   = dffits(model) %>% round(digits = 3),
  "Cooks_D"  = cooks.distance(model) %>% round(digits = 3),
  "DFBETA"   = dfbeta(model) %>% round(digits = 3)
)

sketch <-  htmltools::withTags(table(
  class = 'display',
  thead(
    tr(
      th(rowspan = 2, ""),
      th(rowspan = 2, 'DFFITS'),
      th(rowspan = 2, 'Cooks_D'),
      th(colspan = ncol(dfbeta(model)), 'DFBETA')
    ),
    tr(
      lapply(paste0("b_", 0:(ncol(dfbeta(model))-1)), th)
    )
  )
))

p <- length(coefficients(model))
n <- nrow(model.frame(model))
  
DFFITS_critical <- 2*sqrt(p/n)
CD_50 <- pf(0.5, p, n-p)
CD_20 <- pf(0.2, p, n-p)
DFBETAS_critical <- 2/sqrt(n)

datatable(influentialDF,
          fillContainer = FALSE,
          container = sketch,
          extensions = 'FixedColumns',
          options = list(scrollX = TRUE,
                         fixedColumns = FALSE,
                         pageLength = 10,
                         autoWidth = TRUE,
                         columnDefs = list(list(width = '65px', targets = c(0))))) %>% 
  formatStyle(0:ncol(influentialDF), fontSize = "10pt") %>% 
  formatStyle("DFFITS",
              color = styleInterval(c(-DFFITS_critical, DFFITS_critical), c('red', 'black', 'red'))) %>% 
  formatStyle("Cooks_D",
              color = styleInterval(c(CD_20, CD_50), c("black", "blue", "red")))
```
]

---

# IRLS robust regression

```{r}
model_weight <- lm(agree ~ ., data, weights = IRLS(model_1st, 7)$weights)
. <- summary(model_weight)
.df <- .$coefficients %>% round(digits = 3) %>% as.data.frame()
.df$signif <- symnum(
  .df$"Pr(>|t|)",
  cutpoints = c(0, 0.001, 0.01, 0.05, 0.1, 1),
  symbols = c("***", "**", "*", ".", " ")
)
.df
```

```{r, comment=NA}
write.table(paste("Multiple R-squared:", round(.$r.squared, 3), ", ", "Adjusted R-squared:", round(.$adj.r.squared, 3)), 
            quote = FALSE, row.names = FALSE, col.names = FALSE)
```

---

# IRLS robust regression

---

# bootstrap
.pull-left[
```{r, highlight.output=c()}
bootstrap <- function(model, coef, times = 1000, alpha = 0.05) {
  b     <- coef(model)[[coef]]
  n     <- nrow(model.frame(model))
  coefs <- vector(mode = "numeric", length = times)
  for (i in seq(times))
  {
    estar <- sample(resid(model), size = n, replace = TRUE)
    fstar <- fitted(model) + estar
    bootmodel  <- lm(fstar ~ .-agree, data = model.frame(model))
    coefs[i] <- coef(bootmodel)[[coef]]
  }
  
  p <- quantile(coefs, probs = c(alpha/2, 1-alpha/2))
  
  statistics <- cbind(
    "mean"      = mean(coefs),
    "sd"        = sd(coefs),
    "b(a/2)"    = p[[1]],
    "b(1-a/2)"  = p[[2]])
  
  confint <- cbind(
    'd1'  = b - p[[1]],
    'd2'  = p[[2]] - b,
    'lwr' = 2*b - p[[2]],
    'upr' = 2*b - p[[1]])
  
  return (list(coefs = coefs, statistics = statistics, confint = confint))
}


Stat <- vector(mode="numeric",length = 4)
CI <- vector(mode="numeric",length = 4)
g <- list()
for(i in 1:length(model_weight$coefficients)){
  z <- bootstrap(model_weight, coef=i)
  # hist(z$coefs, breaks = 40, main = "", xlab = names(model_1st$coefficients)[i])
  # title("bootstrap result")
  
  g[[i]] <- ggplot(data.frame(coef = z$coefs), aes(x = coef)) +
    geom_histogram(bins = 40) +
    labs(x = names(model_1st$coefficients)[i], y = NULL) +
    theme_bw()
  
  Stat <- rbind(Stat, z$statistics)
  CI <- rbind(CI, z$confint)
}

gridExtra::grid.arrange(grobs = g, nrow = 2)
```
]
.pull-right[
```{r, comment=NULL}
StatDF <- data.frame(Stat[-1,])
CIDF <- data.frame(CI[-1,])
bootstrap_result <- data.frame(StatDF$mean, StatDF$sd, CIDF$lwr, CIDF$upr, row.names = names(model_1st$coefficients))
names(bootstrap_result) <- c("mean", "sd", "CI_lwr", "CI_upr")
bootstrap_result %>% round(digits = 3)
```
]
---

# model validation

---

class: inverse, center, middle

# 總結

---

# 總結
